1.
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
	buff_dict = {}
	for i in range(len(nums)):
	    if nums[i] in buff_dict:
		return(buff_dict[nums[i]], i)
	    else:
		buff_dict[target - nums[i]] = i

2.
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
      root = cur = ListNode(0)
      carry = 0
      while l1 or l2 or carry:
        if l1:
          carry += l1.val
          l1 = l1.next
        if l2:
          carry += l2.val
          l2 = l2.next
      carry.next = ListNode(carry%10)
      cur = cur.next
      carry //= 10
      return root.next
    
 3.
 class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
    	used_char = {}
	max_length = 0
	start = 0
	for i,c in enumerate(s):
	    if c in used_char and start <= used[c]:
	    	start = used_char[c] + 1
	    else:
	    	max_length = (max_length, i - start + 1)
	    used[c] = i
	 return max_length
	 
4.

5.
class Solution:
    def longestPalindrome(self, s: str) -> str:
    	res = ""
	for i in range(len(s)):
	    tmp = self.helper(s, i, i)
	    if len(tmp) > len(res):
	    	res = tmp
	    tmp = self.helper(s, i, i+1)
	    if len(tmp) > len(res):
	    	res = tmp		   
    def helper(self, s, l, r):
    	while s(l) > 0 and r < len(s) and s[l] == s[r]:
	    l += 1; r -= 1
	return s[l+1:r]

6.

7.
class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
	sign = [1,-1][x<0]
	whole_string = sign * int(str(abs(x))[::-1])
	return whole_string if -(2**31)-1 < rst < 2**31 else 0

8.

9.

10.

11.

class Solution:
    def maxArea(self, height: List[int]) -> int:
    	left = 0
	right = len(height) - 1
	water_area = 0
	while left < right:
	    water_area = max(water_area, (right-left) * min(height[left],height[right]))
	    if heightp[left] < height[right]:
	    	left += 1
	    else:
	    	right -= 1
	return water_area

12.

class Solution(object):
    def intToRoman(self, num):
        dict = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        result = ""
        for letter, n in zip(dict, nums):
            result += letter * int(num / n)
            num %= n
        return result
	
13.

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
    	if not strs:
	    return ""
	s1 = min(strs)
	s2 = max(strs)
	for i,c in enumerate(s1):
	    if c != s2[i]:
	    	return s1[0:i]
	return s1

14.

15.

class Solution:
    def threeSum(self, nums):
        res = []
        nums.sort()
        length = len(nums)
        for i in range(length-2):
            if nums[i] > 0:
                break
            if i > 0 and nums[i] == nums[i-1]:
                continue
            l = i+1
            r = length-1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total < 0:
                    l += 1
                elif total > 0:
                    r -= 1
                else:
                    res.append([nums[i],nums[l],nums[r]])
                    while l < r and nums[l] == nums[l+1]:
                        l += 1
                    while l < r and nums[r] == nums[r-1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res

16.

17.

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', 
                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        if len(digits) == 0:
            return []
        if len(digits) == 1:
            return list(mapping[digits[0]])
        prev = self.letterCombinations(digits[:-1])
        additional = mapping[digits[-1]]
        return [s + c for s in prev for c in additional]

18.

19.

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
    	dummy = ListNode(0)
	dummy.next = head
	fast = slow = dummy
	for _ in range(n):
	    fast = fast.next
	while fast and fast.next:
	    fast = fast.next
	    slow = slow.next
	slow.next = slow.next.next
	return dummy.next

20.

class Solution:
    def isValid(self, s: str) -> bool:
    	stack = []
	dict = {"]":"[", ")":"(", "}":"{"}
	for char in s:
	    if char in dict.values():
	    	stack.append(char)
	    elif char in dict.keys():
	    	if stack == [] or dict[char] != stack.pop():
		    return False
	    else:
	    	return False
	return stack == []
	
21.

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
    	head = cur = ListNode(0)
	while l1 and l2:
	    if l1.val > l2.val:
	    	cur.next = l2
		l2 = l2.next
	    else:
	    	cur.next = l1
		l1 = l1.next
	    cur = cur.next
	cur.next = l1 or l2
	return head.next
	
22.


		

	    	



