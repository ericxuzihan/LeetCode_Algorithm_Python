1.
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
	buff_dict = {}
	for i in range(len(nums)):
	    if nums[i] in buff_dict:
		return(buff_dict[nums[i]], i)
	    else:
		buff_dict[target - nums[i]] = i

2.
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
      root = cur = ListNode(0)
      carry = 0
      while l1 or l2 or carry:
        if l1:
          carry += l1.val
          l1 = l1.next
        if l2:
          carry += l2.val
          l2 = l2.next
      carry.next = ListNode(carry%10)
      cur = cur.next
      carry //= 10
      return root.next
    
 3.
 class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
    	used_char = {}
	max_length = 0
	start = 0
	for i,c in enumerate(s):
	    if c in used_char and start <= used[c]:
	    	start = used_char[c] + 1
	    else:
	    	max_length = (max_length, i - start + 1)
	    used[c] = i
	 return max_length
	 
4.

5.
class Solution:
    def longestPalindrome(self, s: str) -> str:
    	res = ""
	for i in range(len(s)):
	    tmp = self.helper(s, i, i)
	    if len(tmp) > len(res):
	    	res = tmp
	    tmp = self.helper(s, i, i+1)
	    if len(tmp) > len(res):
	    	res = tmp		   
    def helper(self, s, l, r):
    	while s(l) > 0 and r < len(s) and s[l] == s[r]:
	    l += 1; r -= 1
	return s[l+1:r]

6.

7.
class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
	sign = [1,-1][x<0]
	whole_string = sign * int(str(abs(x))[::-1])
	return whole_string if -(2**31)-1 < rst < 2**31 else 0
